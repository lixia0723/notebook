# **Web缓存策略有哪些？**

强缓存

协商缓存

策略缓存

![](https://github.com/lixia0723/notebook/blob/master/assets/images/Web%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.jpg)

![](C:/Users/35967/Desktop/note/assets/images/Web%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.jpg)

### 1. 对浏览器的缓存机制的理解

**浏览器缓存的全过程：**

- 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；
- 下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；
- 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；
- 服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；
- 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；

![业务流程图1.png](https://cdn.nlark.com/yuque/0/2021/png/1500604/1618399660902-60a33dae-cedc-4bd0-9a5b-160c5da3f516.png)

很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。

看到这里，不知道你是否存在这样一个疑问:**如果什么缓存策略都没设置，那么浏览器会怎么处理？**

对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。

### 2. 浏览器资源缓存的位置有哪些？

资源缓存的位置一共有 4 种，按优先级从高到低分别是：

1. **Service Worker：**使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。它可以让我们**自由控制**缓存哪些文件、如何匹配缓存、如何读取缓存，并且**缓存是持续性的**。

   Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。

   当 Service Worker 没有命中缓存的时候，需要去调用 `fetch` 函数获取  数据。也就是说，如果没有在 Service Worker 命中缓存，会根据缓存查找优先级去查找数据。**但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示是从 Service Worker 中获取的内容。**

2. **Memory Cache：**Memory Cache 就是内存缓存，它的效率最快，**但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。**一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。

3. **Disk Cache：**Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache **胜在容量和存储时效性上。**在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。**并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。**

4. **Push Cache：**Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。**并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。**其具有以下特点：

- 所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好
- 可以推送 `no-cache` 和 `no-store` 的资源
- 一旦连接被关闭，Push Cache 就被释放
- 多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存
- Push Cache 中的缓存只能被使用一次
- 浏览器可以拒绝接受已经存在的资源推送
- 可以给其他域名推送资源



**浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？** 关于这点，网上说法不一，不过以下观点比较靠得住：

- 对于大文件来说，大概率是不存储在内存中的，反之优先
- 当前系统内存使用率高的话，文件优先存储进硬盘

### 3. 协商缓存和强缓存的区别

#### （1）强缓存

使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。



**强缓存**策略可以通过**两种方式来设置**，分别是 http 头信息中的 **Expires 属性和 Cache-Control 属性。**

**1.Expires**

（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。==这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致==，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。

（2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，==它提供了对资源的缓存的更精确的控制==。它有很多不同的值

**2.Cache-Control**

`Cache-Control`可设置的字段：

- `public`：设置了该字段值的资源表示==可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存==。这个字段值不常用，一般还是使用max-age来精确控制；

- `private`：设置了该字段值的资源==只能被用户浏览器缓存==，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；

- `no-cache`：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；==强缓存失效，协商缓存有效==

- `no-store`：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；

  ==强制缓存，协商缓存都失效==

- `max-age=`：设置缓存的==最大有效期==，单位为秒；

- `s-maxage=`：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；

- `max-stale[=]`：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。



一般来说只需要设置其中一种方式就可以实现强缓存策略，当**两种方式一起使用时，Cache-Control 的优先级要高于 Expires。**



**no-cache和no-store很容易混淆：**

- no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说==没有强缓存，但是会有协商缓存==；
- no-store 是指==不使用任何缓存==，每次请求都直接从服务器获取资源。

#### （2）协商缓存

如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。



上面已经说到了，命中**协商缓存的条件有两个**：

- `max-age=xxx` 过期了
- 值为`no-store`



使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。



**协商缓存**也可以**通过两种方式来设置**，分别是 http 头信息中的 **Etag** 和 **Last-Modified** 属性。

（1）服务器通过在响应头中==添加 Last-Modified 属性来指出资源最后一次修改的时间==，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个**缺点**，就是 **Last-Modified 标注的最后修改时间只能精确到秒级**，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。

（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，==这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变==。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。



当 Last-Modified 和 Etag 属性同时出现的时候，==Etag 的优先级更高==。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。

**3.两者之间对比：**

- 首先在精确度上，Etag要优于Last-Modified。

Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。

- 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。
- 第三在优先级上，服务器校验优先考虑Etag

==**总结：**==

强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，==**区别**只在于协商缓存会向服务器发送一次请求。==它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。

### 4. 为什么需要浏览器缓存？

==对于浏览器的缓存，主要针对的是前端的静态资源==，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。



所谓的**浏览器缓存**指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。



==使用浏览器缓存，有以下优点：==

- 减少了服务器的负担，提高了网站的性能
- 加快了客户端网页的加载速度
- 减少了多余网络数据传输

### 5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？

- **点击刷新按钮或者按 F5：**浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。

  ==强制缓存失效，协商缓存有效==

- **用户按 Ctrl+F5（强制刷新）：**浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。

  ==强制缓存失效，协商缓存失效==

- 地址栏回车： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。

  ==强制缓存有效，协商缓存有效==

### 6、实际场景应用缓存策略

**1.频繁变动的资源**

> Cache-Control: no-cache

对于频繁变动的资源，首先需要使用`Cache-Control: no-cache` 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。

**2.不常变化的资源**

> Cache-Control: max-age=31536000

通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 `max-age=31536000` (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。 在线提供的类库 (如 `jquery-3.3.1.min.js`, `lodash.min.js` 等) 均采用这个模式。



![](https://static.ecool.fun//article/e97ed6fc-a8d2-4ae0-a361-fbe1349c47b0.awebp)

### 常见考点

1. **缓存的基本概念**
2. **强缓存 vs. 协商缓存**
3. **强缓存**：`Cache-Control`、`Expires`
4. **协商缓存**：`ETag`、`Last-Modified`
5. **缓存优先级**：强缓存 > 协商缓存 > 无缓存
6. **缓存的生命周期**
7. **缓存控制指令**：`max-age`、`s-maxage`、`no-cache`、`no-store`、`must-revalidate`
8. **Cache-Control的常见值及作用**
9. **浏览器缓存的类型**：内存缓存、磁盘缓存
10. **HTTP请求中的缓存相关头部**：`If-None-Match`、`If-Modified-Since`
11. **Service Worker缓存**
12. **缓存的影响因素**：请求头、响应头、用户设置等
13. **跨域资源缓存问题**：CORS和缓存
14. **缓存清除机制**
15. **缓存穿透与缓存雪崩问题**
16. **CDN与缓存**
17. **版本控制和缓存更新策略**

### 关联面试题

[协商缓存中，有了 Last-Modified，为什么还会出现 ETag？](https://fe.ecool.fun/topic/4c33c24c-2e00-49a8-9f70-14c9ed80bf32)

[浏览器缓存中 Memory Cache 和 Disk Cache，有什么区别？](https://fe.ecool.fun/topic/67bb706f-a325-4e89-9940-05ab3bcf4bf6)

[从存储位置看，浏览器缓存分为哪几种？](https://fe.ecool.fun/topic/6d437b44-17fe-4e37-b02e-ed7c7ddb2b80)

[强缓存和协商缓存分别是什么？](https://fe.ecool.fun/topic/7f7e5941-1079-476a-8a62-8ca51879c7ab)

[浏览器有哪几种缓存，各种缓存的优先级是什么样的？](https://fe.ecool.fun/topic/ac644e0a-1fbe-4e0a-9f9f-ecc373a13a87)

[Http 缓存策略，有什么区别，分别解决了什么问题](https://fe.ecool.fun/topic/b97ddbf9-57fd-493f-888d-1ffb7981f10a)

Service Worker 是如何缓存 http 请求资源的？

### 延伸知识

光记住这些理论是不够的，还需要深入在实际场景中去运用。至少要思考如下几个问题：

- HTML文件应该采用哪种缓存？强缓存还是协商缓存？

  对于HTML文件，选择强缓存还是协商缓存主要取决于内容更新频率及对最新数据的需求。

  如果你确定某个HTML文件不会频繁变化，可以选择使用强缓存，并结合版本控制（如文件名哈希）的方法，在文件内容更新时自动使旧缓存失效。

  对于那些可能会频繁更新的HTML页面，建议使用协商缓存机制，以确保用户能够获取到最新的页面内容，同时也能有效利用缓存减少重复下载。

- JS/CSS/图片，应该采用哪种方式？

  对于JS、CSS、图片等静态资源，则更适合采用长期强缓存结合版本化或内容哈希的方式，以最大化利用缓存带来的性能优势。这些静态资源，推荐设置较长的缓存时间（如一年），并通过在文件名中嵌入内容哈希值（contenthash）或者在URL后面添加版本号作为查询参数的方式（如`xxx.js?v=20240719`）来处理更新问题。当文件内容发生改变时，生成的新文件将具有不同的名称或查询参数，从而绕过浏览器缓存，确保用户能够获取到最新版本的资源。

- webpack打包时的 contenthash 是做什么的？

  在使用 Webpack 进行打包时，`contenthash` 是一个非常有用的特性，它主要用于生成基于文件内容的哈希值，并将其添加到输出文件名中。这种方式特别适用于长期缓存静态资源，比如 JavaScript 和 CSS 文件。

  **使用场景**

  当你配置 Webpack 的输出选项 `output.filename` 时，可以通过包含 `[contenthash]` 来启用此功能。例如：

  ```
  module.exports = {
    // 其他配置...
    output: {
      filename: '[name].[contenthash].js',
      path: path.resolve(__dirname, 'dist'),
    },
  };
  ```

  在这个例子中，`[name]` 是入口点的名字，而 `[contenthash]` 则会被替换为根据文件内容计算出的哈希值。这样做的结果是，每次打包后，除非文件内容发生变化，否则生成的文件名保持不变，允许浏览器长期缓存它们。

- 有时候，JS文件名没法修改，我们会在JS的URL最后面加上类似 `xxx.js?v=20240719` 这种query参数，是做什么的？

​	通过向JS文件的URL添加版本查询参数是一种有效的方式来管理和控制静态资源的缓存行为。用于强制浏览器加载最新的JavaScript文件而不是使用缓存版本。这种做法通常被称为“打戳”或“版本戳”。

- 前端打包项目之后生成dist文件夹，里面有哪些文件？

​	**HTML 文件**：这是你的应用或网站的主要入口点。

​	**JavaScript 文件**：这些是经过压缩和优化后的代码文件。

​	**CSS 文件**：如果项目中使用了样式表，打包过程也会对 CSS 进行处理，比如合并、压缩以及有时会将关键CSS直接内联到HTML文档中以提升首次渲染速度。

​	**图片和其他媒体文件**：所有在项目中引用到的图像、字体、视频等媒体资源都会被复制到 `dist` 目录下相应的子目录中。

​	**资源映射文件（Source Maps）**：虽然这不是必须的，但在生产环境中有时也会包含，主要用于调试目的。它将打包后的代码映射回原始源代码的位置，方便开发者追踪错误。

​	**其他配置文件**：某些情况下，还可能需要额外的配置文件来支持特定的功能，例如服务端渲染（SSR）、SEO优化等。

​	HTML文件应该采用哪种缓存？强缓存还是协商缓存？